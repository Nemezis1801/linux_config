#!/bin/bash
# Moduł: Network Configuration - Zapora sieciowa, DNS
# Plik: modules/network_config.sh

# --- Konfiguracja DNS (Podstawowa - /etc/resolv.conf) ---
# Uwaga: Ta metoda jest prosta, ale może być nadpisywana przez NetworkManager,
# systemd-resolved lub dhclient. Bardziej niezawodne metody wymagają
# konfiguracji specyficznych narzędzi zarządzania siecią.
configure_dns_basic() {
    log_msg "Configuring DNS servers (basic /etc/resolv.conf method)..."

    # Wyświetl ostrzeżenie użytkownikowi
    if command -v $UI_TOOL > /dev/null; then
        show_message "$MSG_DNS_RESOLVCONF_WARN"
    else
        log_warn "$MSG_DNS_RESOLVCONF_WARN"
    fi

    # Zapytaj o kontynuację
    if ! confirm_action "$PROMPT_CONFIG_DNS"; then
        log_msg "$MSG_DNS_SKIPPED"
        return 1 # Anulowano
    fi

    # Zbierz adresy IP serwerów DNS od użytkownika
    local dns_servers=()
    while true; do
        local ns
        ns=$(ask_input "$PROMPT_DNS_IP" "")
        local input_status=$?
         # Jeśli naciśnięto Anuluj w inputbox
        if [ $input_status -ne 0 ]; then
            log_msg "$MSG_ACTION_CANCELLED"
            return 1
        fi
        # Jeśli wpisano pustą wartość, zakończ pętlę
        if [ -z "$ns" ]; then
            break
        fi
        # Prosta walidacja IP (tylko format, nie osiągalność)
        if [[ "$ns" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
             dns_servers+=("$ns")
             log_msg "Added DNS server: $ns"
        else
             log_warn "$(printf "Invalid IP address format: '%s'. Ignoring." "$ns")"
             if command -v $UI_TOOL >/dev/null; then
                show_message "$MSG_DNS_INVALID_IP"
             fi
        fi
    done

    # Sprawdź, czy zebrano jakieś serwery DNS
    if [ ${#dns_servers[@]} -eq 0 ]; then
        log_msg "$MSG_DNS_NO_SERVERS"
        return 0 # Nie wprowadzono serwerów, ale nie jest to błąd
    fi

    # Zrób backup istniejącego /etc/resolv.conf
    create_backup "/etc/resolv.conf" || return 1 # Przerwij, jeśli backup się nie uda

    log_warn "$MSG_DNS_WRITE_WARN"

    # Przygotuj zawartość nowego pliku resolv.conf
    local resolv_content="# Generated by Linux Setup Manager ($(date +%Y-%m-%d_%H:%M:%S))\n"
    resolv_content+="# Warning: May be overwritten by NetworkManager/systemd-resolved/dhclient\n"
    for server in "${dns_servers[@]}"; do
        resolv_content+="nameserver $server\n"
    done

    # Zapisz nowy plik resolv.conf za pomocą tee z sudo
    if printf "%b" "$resolv_content" | sudo tee /etc/resolv.conf > /dev/null; then
        log_msg "$(printf "$MSG_DNS_SET" "${dns_servers[*]}")"
        CONFIG_CHANGES_MADE=true
        # Restart sieci może być potrzebny, ale jest ryzykowny do automatyzacji
        log_warn "DNS servers set in /etc/resolv.conf. Network restart might be needed for changes to apply immediately."
        return 0
    else
        log_error "Failed to write to /etc/resolv.conf. Check permissions."
        if command -v $UI_TOOL >/dev/null; then
             show_message "ERROR: Failed to write to /etc/resolv.conf."
        fi
        return 1
    fi
}

# --- Konfiguracja Zapory Sieciowej (UFW lub firewalld) ---
# Wykrywa dostępne narzędzie i wywołuje odpowiednią funkcję konfiguracyjną.
configure_firewall() {
    log_msg "Configuring Firewall..."
    local firewall_tool=""
    local firewall_pkg=""
    local is_active="unknown" # Zmień na string

    # Wykryj narzędzie i jego status
    # Sprawdź UFW
    if command -v ufw > /dev/null 2>&1; then
        firewall_tool="ufw"
        firewall_pkg="ufw"
        # Wyłącz 'set -e' na czas sprawdzania statusu
        set +e
        if sudo ufw status | grep -q "Status: active"; then is_active="active"; else is_active="inactive"; fi
        set -e
        log_msg "$(printf "$MSG_FIREWALL_DETECTED" "UFW" "$is_active")"
    # Sprawdź firewalld
    elif command -v firewall-cmd > /dev/null 2>&1; then
         firewall_tool="firewalld"
         firewall_pkg="firewalld"
         set +e
         if sudo firewall-cmd --state 2>/dev/null | grep -q "running"; then is_active="active"; else is_active="inactive"; fi
         set -e
         log_msg "$(printf "$MSG_FIREWALL_DETECTED" "firewalld" "$is_active")"
    else
         log_warn "$MSG_FIREWALL_NONE"
         # Zapytaj czy zainstalować UFW jako domyślny (jeśli system Debian/Ubuntu)
         if [[ "$PKG_MANAGER" == "apt" ]] && ask_yesno "$PROMPT_INSTALL_UFW"; then
              log_msg "Attempting to install UFW..."
              # Wywołaj install_packages z modułu package_manager
              if install_packages ufw; then
                  firewall_tool="ufw"
                  firewall_pkg="ufw"
                  is_active="inactive" # Nowo zainstalowany jest nieaktywny
                  log_msg "UFW installed successfully."
              else
                   log_error "Failed to install UFW. Cannot configure firewall."
                   return 1
              fi
         # Można dodać podobną logikę dla firewalld na systemach RPM
         # elif [[ "$PKG_MANAGER" == "dnf" || "$PKG_MANAGER" == "yum" ]] # etc.
         else
             log_msg "$MSG_FIREWALL_NONE_SKIPPED"
             # Pokaż wiadomość w UI, jeśli dostępne
              if command -v $UI_TOOL >/dev/null; then
                 show_message "$MSG_FIREWALL_NONE_SKIPPED"
              fi
             return 0 # Nie traktuj braku firewalla jako błędu skryptu
         fi
    fi

    # Zapytaj użytkownika, czy chce skonfigurować wykryty/zainstalowany firewall
    if ! confirm_action "$(printf "$PROMPT_CONFIG_FIREWALL" "$firewall_tool")"; then
        log_msg "$MSG_FIREWALL_CONFIG_SKIPPED"
        return 1 # Anulowano
    fi

    # Wywołaj odpowiednią funkcję konfiguracyjną
    local config_status=1 # Domyślnie błąd
    if [ "$firewall_tool" == "ufw" ]; then
        configure_ufw "$firewall_pkg"
        config_status=$?
    elif [ "$firewall_tool" == "firewalld" ]; then
        configure_firewalld "$firewall_pkg"
        config_status=$?
    fi

    # Jeśli konfiguracja się powiodła, pokaż status
    if [ $config_status -eq 0 ]; then
        log_msg "$(printf "$MSG_FIREWALL_STATUS" "$firewall_tool")"
        local status_output=""
         # Wyłącz 'set -e' na czas pobierania statusu
         set +e
        if [ "$firewall_tool" == "ufw" ]; then
            status_output=$(sudo ufw status verbose 2>&1)
        elif [ "$firewall_tool" == "firewalld" ]; then
             status_output=$(sudo firewall-cmd --list-all 2>&1)
        fi
         set -e
         log_msg "Firewall Status Output:\n$status_output"
         # Pokaż w UI
         if command -v $UI_TOOL > /dev/null; then
             # Ogranicz długość dla msgbox
              show_message "Firewall configured. Current Status:\n\n$(echo "$status_output" | head -n 15)"
         fi
         CONFIG_CHANGES_MADE=true
         NEEDS_REBOOT=true # Zmiany w zaporze mogą wymagać restartu dla pewności
    fi

    return $config_status
}

# Konfiguruje UFW
# $1: Nazwa pakietu UFW (przekazana z configure_firewall)
configure_ufw() {
    local ufw_pkg=$1
    log_msg "$(printf "$MSG_FIREWALL_CONFIGURING" "UFW")"

    # Upewnij się, że UFW jest zainstalowany (chociaż powinno być sprawdzone wcześniej)
    if ! is_package_installed "$ufw_pkg"; then
        log_warn "UFW package '$ufw_pkg' not found, attempting installation again."
        install_packages "$ufw_pkg" || return 1 # Wyjdź z funkcji jeśli instalacja się nie uda
    fi

    # Ustaw domyślne zasady
    log_msg "Setting UFW defaults: deny incoming, allow outgoing."
    sudo ufw default deny incoming || log_warn "Failed to set default deny incoming."
    sudo ufw default allow outgoing || log_warn "Failed to set default allow outgoing."
    log_msg "$MSG_FIREWALL_DEFAULTS"

    # Zezwól na SSH (Kluczowe!)
    # Odczytaj port z konfiguracji SSHD, jeśli to możliwe
    local ssh_port=22 # Domyślny
    local sshd_config_file="/etc/ssh/sshd_config"
    if [ -f "$sshd_config_file" ]; then
        # Wyłącz 'set -e' na czas grep
        set +e
        local port_line=$(grep -iE "^\s*Port\s+" "$sshd_config_file" | head -n 1)
        set -e
        if [ -n "$port_line" ]; then
            ssh_port=$(echo "$port_line" | awk '{print $2}')
            # Prosta walidacja czy to liczba
            if ! [[ "$ssh_port" =~ ^[0-9]+$ ]]; then ssh_port=22; fi
        fi
    fi
    log_msg "Current SSH port detected/assumed: $ssh_port"
    if ask_yesno "$(printf "$PROMPT_ALLOW_SSH" "$ssh_port")"; then
        if ! sudo ufw allow "$ssh_port/tcp"; then
             log_error "Failed to allow SSH on port $ssh_port/tcp."
             # To krytyczne, może lepiej przerwać?
             show_message "ERROR: Failed to allow SSH port $ssh_port/tcp. Firewall configuration might lock you out!"
             return 1
        fi
        log_msg "$(printf "$MSG_FIREWALL_ALLOWED_SSH" "$ssh_port")"
    else
        log_warn "SSH port $ssh_port/tcp NOT allowed. Ensure you have alternative access if enabling the firewall!"
        show_message "WARNING: SSH port $ssh_port/tcp was NOT allowed. Ensure you have console access or other means if you enable the firewall!"
    fi

    # Zezwól na standardowe porty WWW, jeśli serwer jest zainstalowany
    if is_package_installed apache2 || is_package_installed httpd || is_package_installed nginx; then
         if ask_yesno "$PROMPT_ALLOW_HTTP"; then
             if sudo ufw allow http; then log_msg "$MSG_FIREWALL_ALLOWED_HTTP"; else log_warn "Failed to allow HTTP."; fi
         fi
         if ask_yesno "$PROMPT_ALLOW_HTTPS"; then
             if sudo ufw allow https; then log_msg "$MSG_FIREWALL_ALLOWED_HTTPS"; else log_warn "Failed to allow HTTPS."; fi
         fi
    fi

    # Pozwól użytkownikowi dodać niestandardowe reguły
    while true; do
        local custom_rule
        custom_rule=$(ask_input "$PROMPT_ALLOW_PORT" "")
        local input_status=$?
        if [ $input_status -ne 0 ] || [ -z "$custom_rule" ]; then break; fi # Anuluj lub puste kończy

        # Prosta walidacja formatu (port, port/protokół, nazwa aplikacji)
        if [[ "$custom_rule" =~ ^[0-9]+$ ]] || \
           [[ "$custom_rule" =~ ^[0-9]+/(tcp|udp)$ ]] || \
           [[ "$custom_rule" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            log_msg "Attempting to allow custom rule: $custom_rule"
            if ! sudo ufw allow "$custom_rule"; then
                 log_warn "Failed to add custom rule '$custom_rule'. It might be invalid."
                 show_message "Failed to add custom rule '$custom_rule'. Check syntax/availability."
            else
                 log_msg "$(printf "$MSG_FIREWALL_ALLOWED_CUSTOM" "$custom_rule")"
            fi
        else
             log_warn "Invalid format for custom rule: '$custom_rule'"
             show_message "$MSG_FIREWALL_INVALID_FORMAT"
        fi
     done

    # Włącz UFW
    log_msg "$MSG_FIREWALL_ENABLING UFW..."
    # 'yes |' obsługuje monit UFW przy pierwszym włączeniu
    # Wyłącz 'set -e' na czas włączania
    set +e
    local enable_output
    enable_output=$(yes | sudo ufw enable 2>&1)
    local enable_status=$?
    set -e

    if [ $enable_status -ne 0 ]; then
        log_error "Failed to enable UFW. Status: $enable_status, Output: $enable_output"
        show_message "ERROR: Failed to enable UFW. Check logs."
        return 1
    fi
    log_msg "UFW enable command executed."

    # Upewnij się, że usługa systemd jest włączona (start on boot)
    if ! manage_service ufw enable; then
        log_warn "Could not enable UFW service via systemd, but ufw itself might be active."
    fi
    # Upewnij się, że usługa jest uruchomiona (choć 'ufw enable' powinno to robić)
    # if ! is_service_active ufw; then manage_service ufw start; fi

    log_msg "$(printf "$MSG_FIREWALL_ENABLED" "UFW")"
    return 0
}

# Konfiguruje firewalld
# $1: Nazwa pakietu firewalld
configure_firewalld() {
    local firewalld_pkg=$1
    log_msg "$(printf "$MSG_FIREWALL_CONFIGURING" "firewalld")"

    if ! is_package_installed "$firewalld_pkg"; then
        log_warn "firewalld package '$firewalld_pkg' not found, attempting installation."
        install_packages "$firewalld_pkg" || return 1
    fi

    # Upewnij się, że usługa firewalld jest włączona i działa
    if ! manage_service firewalld enable; then
         log_warn "Failed to enable firewalld service. Configuration might not persist."
    fi
    if ! is_service_active firewalld; then
        if ! manage_service firewalld start; then
             log_error "Failed to start firewalld service. Cannot configure rules."
             show_message "ERROR: Failed to start firewalld service."
             return 1
        fi
    fi
    log_msg "firewalld service is enabled and active."

    # Domyślne zasady są zazwyczaj zarządzane przez strefy (np. public)
    # Nie zmieniamy ich tutaj, ale pozwalamy na dodawanie usług/portów

    # Zezwól na SSH (jako usługa)
    if ask_yesno "$(printf "$PROMPT_ALLOW_SSH" "service ssh")"; then
        log_msg "Allowing SSH service permanently..."
        if ! sudo firewall-cmd --permanent --add-service=ssh; then
             log_error "Failed to add SSH service permanently."
             # Krytyczne? Może nie przerywać, ale ostrzec.
             show_message "ERROR: Failed to permanently allow SSH service."
        else
             log_msg "$(printf "$MSG_FIREWALL_ALLOWED_SSH" "service ssh") (Permanent)"
        fi
    else
        log_warn "SSH service NOT allowed permanently. Ensure you have alternative access if the runtime rule expires or firewalld restarts!"
        show_message "WARNING: SSH service was NOT allowed permanently. Ensure you have console access or other means!"
    fi

    # Zezwól na standardowe usługi WWW, jeśli serwer jest zainstalowany
    if is_package_installed apache2 || is_package_installed httpd || is_package_installed nginx; then
         if ask_yesno "$PROMPT_ALLOW_HTTP"; then
             if sudo firewall-cmd --permanent --add-service=http; then log_msg "$MSG_FIREWALL_ALLOWED_HTTP (Permanent)"; else log_error "Failed to add HTTP service permanently."; fi
         fi
         if ask_yesno "$PROMPT_ALLOW_HTTPS"; then
             if sudo firewall-cmd --permanent --add-service=https; then log_msg "$MSG_FIREWALL_ALLOWED_HTTPS (Permanent)"; else log_error "Failed to add HTTPS service permanently."; fi
         fi
    fi

    # Pozwól użytkownikowi dodać niestandardowe reguły (usługi lub porty)
    while true; do
        local custom_rule
        custom_rule=$(ask_input "$PROMPT_ALLOW_PORT" "")
        local input_status=$?
        if [ $input_status -ne 0 ] || [ -z "$custom_rule" ]; then break; fi

        # Spróbuj dodać jako port/protokół LUB jako usługę
        log_msg "Attempting to allow custom rule permanently: $custom_rule"
        set +e # Wyłącz set -e na czas próby dodania reguły
        if [[ "$custom_rule" =~ ^[0-9]+/(tcp|udp)$ ]]; then
             sudo firewall-cmd --permanent --add-port="$custom_rule"
             local cmd_status=$?
        elif [[ "$custom_rule" =~ ^[a-zA-Z0-9_-]+$ ]]; then # Załóż, że to nazwa usługi
             sudo firewall-cmd --permanent --add-service="$custom_rule"
             local cmd_status=$?
        else
             log_warn "Invalid format for custom rule: '$custom_rule'. Neither port/protocol nor valid service name."
             show_message "$MSG_FIREWALL_INVALID_FORMAT"
             cmd_status=1 # Oznacz jako błąd
        fi
        set -e # Włącz set -e

        if [ $cmd_status -ne 0 ]; then
            log_error "Failed to add custom rule '$custom_rule' permanently. Check syntax/availability."
            show_message "Failed to add custom rule '$custom_rule' permanently. Check logs."
        else
            log_msg "$(printf "$MSG_FIREWALL_ALLOWED_CUSTOM" "$custom_rule") (Permanent)"
        fi
     done

    # Przeładuj konfigurację firewalld, aby zastosować stałe zmiany
    log_msg "$MSG_FIREWALL_RELOADING firewalld..."
    if ! sudo firewall-cmd --reload; then
        log_error "$MSG_FIREWALL_RELOAD_FAILED"
        show_message "ERROR: $MSG_FIREWALL_RELOAD_FAILED Check logs. Manual reload ('firewall-cmd --reload') or restart might be needed."
        return 1 # Przeładowanie jest ważne, potraktuj jako błąd
    fi
    log_msg "$(printf "$MSG_FIREWALL_RELOADED" "firewalld")"
    return 0
}


# --- Główna funkcja modułu Konfiguracji Sieci ---
# Wyświetla podmenu
run_network_config_menu() {
     while true; do
        local choice
        choice=$(show_menu "$SUBMENU_NETWORK_CONFIG_TITLE" "$SUBMENU_NETWORK_CONFIG_DESC" \
            "FIREWALL" "$OPT_CONFIG_FIREWALL" \
            "DNS" "$OPT_CONFIG_DNS (Basic)" \
            "BACK" "$OPT_NETWORK_BACK")
        local exit_status=$?
        [ $exit_status -ne 0 ] && choice="BACK"

        case "$choice" in
            FIREWALL) configure_firewall ;;
            DNS) configure_dns_basic ;;
            BACK) break ;;
            *) log_warn "Invalid choice in network config menu: $choice" ;;
        esac
        # if [ "$choice" != "BACK" ]; then wait_for_enter; fi
    done
    return 0
}